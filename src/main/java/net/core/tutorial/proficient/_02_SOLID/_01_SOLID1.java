package net.core.tutorial.proficient._02_SOLID;

/**

 SOLID.

 Объектно-ориентированное программирование принесло в разработку ПО новые подходы к проектированию приложений. В частности,
 ООП позволило программистам комбинировать сущности, объединённые некоей общей целью или функционалом, в отдельных классах,
 рассчитанных на решение самостоятельных задач и независимых от других частей приложения. Однако само по себе применение ООП
 не означает, что разработчик застрахован от возможности создания непонятного, запутанного кода, который тяжело поддерживать.
 Роберт Мартин, для того, чтобы помочь всем желающим разрабатывать качественные ООП-приложения, разработал пять принципов
 объектно-ориентированного программирования и проектирования, говоря о которых, с подачи Майкла Фэзерса, используют акроним SOLID.

 S: Single Responsibility Principle (Принцип единственной ответственности).
 O: Open-Closed Principle (Принцип открытости-закрытости).
 L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
 I: Interface Segregation Principle (Принцип разделения интерфейса).
 D: Dependency Inversion Principle (Принцип инверсии зависимостей).

 Single Responsibility Principle.
 Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, то его подсистемы,
 реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.

 Вот что по этому поводу говорит Стив Фентон: «Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные
 компоненты, то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует стараться разделять компоненты,
 изменения в которых вызывают различные причины».

 Правильное применение принципа единственной ответственности приводит к высокой степени связности элементов внутри модуля,
 то есть к тому, что задачи, решаемые внутри него, хорошо соответствуют его главной цели.

 */
public class _01_SOLID1 {
}

// Этот класс нарушает принцип единственной ответственности.
// Он решает две задачи, занимаясь сохранением данных при помощи метода saveAnimal и манипулируя свойствами объекта
// в конструкторе и в методе getAnimalName(). Если изменится порядок работы с хранилищем данных, используемым приложением,
// то придётся вносить изменения во все классы, работающие с хранилищем. Такая архитектура не отличается гибкостью,
// изменения одних подсистем затрагивают другие, что напоминает эффект домино.
class Animal_1 {

    private String animalName;

    public Animal_1(String animalName) {

        this.animalName = animalName;
    }

    public String getAnimalName() {
        return animalName;
    }

    public void saveAnimal(Animal_1 animal){

        // some code
    }
}

// Рефакторинг кода
class Animal_2 {

    private String animalName;

    public Animal_2(String animalName) {

        this.animalName = animalName;
    }

    public String getAnimalName() {
        return animalName;
    }
}

class Animal_DB {

    public void saveAnimal(Animal_1 animal){

        // some code
    }

    public Animal_2 getAnimal(){

        // some code
        return new Animal_2("Tom");
    }
}
