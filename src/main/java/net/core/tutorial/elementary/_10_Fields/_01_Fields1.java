package net.core.tutorial.elementary._10_Fields;

/**

 Поля класса.

 Поля в классе не виртуальны, как статические, так и нестатические. Т.е. тип полей определяется уже на этапе
 компиляции. Однако, если считывается поле класса наследника, а у наследника нет поля с таким названием, то компилятор
 проверит, нет ли этого же поля (с подходящим уровнем доступа) у предков.

 Поля в классе не виртуальны, т.е. при создании объекта класса наследника выделяется область памяти для хранения
 всех полей самого наследника, а также всех полей, которые есть в классах предков. При этом, если в наследнике
 объявить поле с таким же именем, как и у предка, то в объекте будут оба эти поля с одинаковыми именами. Какое из этих
 двух полей будет видно снаружи (доступно из объекта) определяется типом переменной, в которую сохраняется ссылка
 на объект наследника. У наследника свои собственные поля, а не ссылки на поля предков.
 Кроме этого к переменной предка (если позволяет уровень доступа) можно обратиться в классе наследника через super.field.

 Пусть имеется класс предок, у которого есть приватное поле, значение которого используется в некотором публичном
 методе в этом же классе. И есть класс наследник, у которого есть одноимённое поле с другим значением, но нет
 указанного метода. Значит наследник унаследует данный метод от своего предка. Теперь, если из объекта наследника
 вызвать такой унаследованный метод, то в нём будет использовано значение переменной из класса предка,
 а не значение одноимённой переменной из класса наследника. Поскольку переменные не виртуальны, то уже на этапе
 компиляции решается, какую из переменных использовать. Т.е. будет использована переменная из того же класса,
 в котором находится метод. А если переопределить данный метод в классе наследника, то будет вызываться именно он
 и в нём будет использовано значение переменной из класса наследника.

 */

public class _01_Fields1 {

    public static void main(String[] args) {

        A a = new A2();
        B b = new B2();

        System.out.println("Тип переменной определяет то, значение поля из какого класса будет использовано:");
        System.out.println("a.num1 = " + a.num1 + ", b.num2 = " + b.num2);
        System.out.println("Но в объекте наследника в любом случае хранятся и значения переменных (даже одноимённых)" +
                " предков и значения собственных переменных");
        System.out.println("-------------------------------");

        C2 c2 = new C2();
        System.out.println("Сумма значений value наследника и предка (доступ к полю предка через super.value) равна: "
                + c2.returnSumValuesFromParentAndChild());
        System.out.println("-------------------------------");

        D d2 = new D2();
        d2.printName();
        System.out.println("Несмотря на то, что поле value у класса предка приватное, в объекте наследника хранится и оно тоже");
    }
}

class A {

    int num1 = 10;
}

class B {

    int num2 = 20;
}

class A2 extends A {

    int num1 = 1000;
}

class B2 extends B {

    int num2 = 2000;
}

class C {

    public int value = 33;
}

class C2 extends C {

    public int value = 77;

    public int returnSumValuesFromParentAndChild() {

        return (value + super.value);
    }
}

class D {

    private String name = "Ihor";

    public void printName() {

        System.out.println("My name is " + name);
    }
}

class D2 extends D {

    public String name = "Inga";
}