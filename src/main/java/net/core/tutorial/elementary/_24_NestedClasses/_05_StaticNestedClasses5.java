package net.core.tutorial.elementary._24_NestedClasses;

/**

 nested класс может быть объявлен внутри метода, конструктора или логического блока (инициализатора)
 внешнего класса. Такой класс называется локальным.

 Видимость такого класса регулируется областью видимости блока, в котором он объявлен, т.е. объект такого
 nested класса можно создать только внутри текущего метода или логического блока.

 Из inner класса, объявленного внутри нестатического метода, можно напрямую обратиться к статическим
 и нестатическим переменным внешнего класса, а так же к локальным переменным метода.

 Из static nested класса, объявленного внутри статического метода, можно напрямую обратиться к статическим
 переменным внешнего класса и к локальным переменным метода (нестатическим, т.к. метод не может содержать
 статических переменных). В таком static nested классе не может содержаться статических переменных или методов
 (так как сам класс объявлен внутри метода). Из static nested класса можно обратиться к нестатической переменной
 внешнего класса, только создав его объект.

 Внутри статического метода нельзя объявить локальный статический класс явно. Но nested класс, объявленный
 внутри статического метода автоматически считается локальным static nested классом.

 Частным случаем локального класса является анонимный класс.
 Анонимный класс, объявленный в статическом контексте (внутри статического метода, static nested класса,
 статической секции инициализации) сам является static nested классом. Иначе анонимный класс является inner классом.
 Анонимный класс внутри конструктора также inner, т.к. конструктор не может быть статическим.

 Анонимный класс не может быть top level.

 Анонимный класс всегда nested класс. А значит имеет доступ к переменным внешнего класса
 (из static nested класса нет доступа к нестатическим переменным).

 Пусть анонимный класс объявлен внутри метода. Тогда, если внутри анонимного класса необходимо использовать
 локальную переменную метода, то она должна быть final (константой, которую можно читать, но нельзя изменять).
 В Java 8+ это может быть переменная без модификатора final, но она должна быть фактически финальной,
 т.е. не должна изменяться. Если final объявлена ссылочная переменная, то это означает, что не может измениться
 значение самой ссылки (локальной переменной). Это касается не только анонимных классов, а любых внутренних классов.

 Анонимный класс можно стартовать в другом потоке. И если бы в анонимном классе использовались не финальные
 переменные, то это бы означало, что метод в одном потоке смог бы изменять локальные переменные метода
 в другом потоке. А это запрещено. Разные потоки могут получить доступ к одному и тому же объекту в Heap
 (полям класса), но здесь для устранения проблем можно использовать Monitor.

 */

public class _05_StaticNestedClasses5 {

    static int value1 = 2002;

    public static void main(String[] args) {

        anotherMethod();
    }

    public static void anotherMethod() {

        /*final*/ int finalValue = 333;

        class AnotherStaticNestedClass {

            public int calculate(int value2) {

                return value1 * value2 + finalValue;
            }

            @Override
            public String toString() {
                return "AnotherStaticNestedClass{}";
            }
        }

        int calculated = new AnotherStaticNestedClass().calculate(30);
        System.out.println("Calculated: " + calculated);
    }
}
