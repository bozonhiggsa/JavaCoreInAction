package net.core.tutorial.elementary._02_TypesOfMemory;

/**
 Heap.

 Область памяти, где хранятся ссылочные объекты. Область в Heap выделяется после инструкции new (строки, массивы, коллекции,
 объекты классов), а также при использовании строкового литерала при создании строки.

 Объект удаляется из Heap, только когда исчезают все ссылки на него из стека или из Perm Gen. Причём ссылки могут
 храниться как в локальных переменных в стеке, так и в самом Heap, например в элементах коллекции. Но на конечный объект
 прямо или опосредовано должна быть ссылка из локальной переменной метода (из стека) или из Perm Gen.
 Т.е. если обнулить ссылку в локальной переменной (в стеке) на коллекцию, то удалится как объект коллекции, так и объект,
 на который была ссылка в элементе коллекции.
 В Java, в отличие от C++, нет никакой возможности в самом объекте узнать, сколько ссылок ведут к нему.
 Объекты без ссылок (из стека или из Perm Gen) удаляются из Heap сборщиком мусора, который запускается время от времени.
 Если для объекта переопределён метод finalize(), то перед уничтожением объекта возможно запустится данный метод.
 OutOfMemoryError – исключение – вылетает, когда заканчивается память в Heap.

 Но если в бесконечном цикле создавать объекты в Heap, на которые в локальных переменных нет ссылок,
 то они будут последовательно уничтожаться мусорщиком и исключение не будет вылетать.

 Когда в Heap заканчивается память, то запускается мусорщик, который идёт по всем ссылкам из локальных переменных (из стека)
 и по всем ссылкам из статических полей (из Perm Gen). Найденные по ссылкам объекты он оставляет, а вся остальная область памяти
 считается свободной (все остальные объекты удаляются).
 Для чистоты программирования на Java лучше создавать в процессе выполнения программы много объектов через new,
 но не сохранять ссылки на них, чем создавать мало объектов и сохранять ссылки на них в локальные переменные.

 Операция создания объекта через new очень быстрая, а фазы уничтожения объектов нет вовсе. Т.е. если созданы
 миллион объектов на которых уже нет ссылок и есть сто живых объектов, то сборщик мусора находит только
 живые объекты, а про миллион остальных просто забывает, считая, что вся оставшаяся в Heap память свободна.
 Сборщик мусора должен по идее по умолчанию перед уничтожением объекта вызывать метод .finilize(),
 но поскольку этот метод, по умолчанию, если его не переопределить, ничего не делает, то на самом деле,
 сборщик мусора его и не вызывает, а просто забывает про мёртвые объекты. Если же переопределить .finilize(),
 то менеджеру памяти приходится помнить ссылку на все созданные объекты, даже уже мёртвые. И тогда система
 начинает работать намного медленнее.
 Когда сборщик мусора прошёлся по ссылкам на живые объекты, то он перемещает их в памяти на соседние участки
 (выполняет дефрагментацию). При этом свободная область памяти тоже будет сплошняком, благодаря чему выделять
 память под вновь создаваемые объекты очень просто и new выполняется очень быстро.

 Чтобы задать стартовое значение размера Heap, равное 64 Мбайт, необходимо установить следующий флаг:

 -Xms64m

 задание максимального размера:

 -Xmx64m – размер максимального размера Heap

 Также для JVM выделяется ещё некоторая область памяти за пределами Heap, к которой можно получить доступ при помощи
 класса ByteBuffer. Здесь не лазит мусорщик.

 */

public class _03_Heap {

}