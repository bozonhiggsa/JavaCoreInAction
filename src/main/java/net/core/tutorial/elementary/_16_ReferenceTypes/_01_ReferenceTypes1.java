package net.core.tutorial.elementary._16_ReferenceTypes;

/**

 Ссылочные типы.

 Ссылочными типами в Java являются:
 1.	Class (включая Enum);
 2.	Interface (включая Annotation);
 3.	Array (built-n type);
 4.	Null-type.

 Объект создаётся при помощи оператора new и его класс определяется в момент создания.
 Класс объекта после нельзя изменить. Ссылку на объект можно хранить в переменной его же класса или в переменной
 класса-предка.

 */
public class _01_ReferenceTypes1 {

    public static void main(String[] args) {

        // Пусть имеется класс-предок Object, наследником которого является A1.
        // У класса A1 также есть наследник A2. У класса A2 также есть наследник A3.
        // У класса A3 также есть наследник A4. Рассмотрим случаи:

        // Если создать объект класса A3 и присвоить ссылку на него переменной этого же класса A3:
        A3 a3 = new A3();
        //то из объекта a3 можно будет вызывать все методы, которые есть у класса A3
        a3.method1();
        a3.method2();
        a3.method3();
        System.out.println("---------------------------");

        // Если создать объект класса A3 и присвоить ссылку на него переменной класса-предка A1:
        A1 a1 = new A3();
        // то произойдёт сужение типа и из объекта a1 можно будет вызывать лишь те методы, которые есть у класса A1.
        // В реализации класса A3, если A3 их переопределил, или унаследованные у класса A1.
        a1.method1();
        System.out.println("---------------------------");

        // Сужение типа можно продолжить:
        Object obj = a1;
        // и этим ещё больше сузить набор доступных для использования из объекта методов.
        System.out.println(obj.toString());
        System.out.println(obj.hashCode());
        System.out.println("---------------------------");

        // А можно расширить тип ссылочной переменной вплоть до класса объекта:
        A2 a2 = (A2) obj; // расширение типа ссылочной переменной
        // теперь ссылка на объект класса A3 хранится в переменной класса-предка A2, т.е. из объекта можно вызывать все
        // методы, которые есть в классе A2.
        a2.method1();
        a2.method2();
        System.out.println("---------------------------");

        A3 a3m = (A3) a2;
        // теперь ссылка на объект класса A3 хранится в переменной класса A3, т.е. из объекта можно вызывать все методы,
        // которые есть в классе A3.

        // При расширении типа (type cast) необходимо использовать оператор приведения типа.
        // Эта операция выполняется не во время компиляции, а на этапе исполнения программы.


        // Но нельзя расширить тип ссылочной переменной до класса-наследника объекта:
        try{
            A4 a4 = (A4) a3m; // Возникнет исключение
        }
        catch (ClassCastException e){
            System.out.println("Возникло исключение ClassCastException - нельзя расширять тип объекта до наследника исходного типа");
        }

    }
}

// Класс неявно является наследником класса Object
class A1 {

    public void method1() {

        System.out.println("This is method 1");
    }
}

class A2 extends A1 {

    public void method2() {

        System.out.println("This is method 2");
    }
}

class A3 extends A2 {

    public void method3() {

        System.out.println("This is method 3");
    }
}

class A4 extends A3 {

    public void method4() {

        System.out.println("This is method 4");
    }
}