package net.core.tutorial.elementary._11_Methods;

/**

 Статические методы не наследуются и, поэтому, не переопределяются. И, поэтому, не могут быть абстрактными.
 Статический метод является общим для класса и его наследников. Нельзя переопределить статический метод, но можно
 создать в классе наследника метод с такой же сигнатурой. Такой метод называется закрывающим/перекрывающим (hiding).
 Закрытый метод можно вызвать, если позволяет уровень доступа, по имени класса-предка или при помощи super внутри
 класса наследника.

 Если в классе наследника не объявляется закрывающий метод, то по имени класса наследника или из его объекта можно
 напрямую вызвать статический метод предка (если позволяет уровень доступа).
 Если в коде вызывается статический метод, то уже на этапе компиляции решается, у какого класса он будет вызван.
 А значит это будет тот класс, переменная которого анализируется компилятором (или тот класс, по имени которого вызывается
 статический метод). В этом случае на этапе исполнения программы уже не будет анализироваться, на объект какого типа
 ссылается переменная.

 Как при переопределении нестатических методов, так и при объявлении закрывающих статических методов справедливо следующее.

 1. Метод наследника должен возвращать тот же тип (или тип-наследника), что и возвращаемый тип в методе предка.

 2. Метод наследника не может кидать исключение более широкое, чем в методе предка. Если в методе предка кидается исключение,
 то оно может не кидаться в методе наследника. Но если в методе предка не кидается исключение, то в методе наследника
 не может кидаться какое-либо контролируемое исключение.

 3. Нельзя в наследнике изменять статичность метода и закрывать его уровень доступа (например с public на protected).

 Статический метод можно перегрузить (overload) в наследнике нестатическим методом c другим набором аргументов.
 Статический метод нельзя перекрыть в наследнике нестатическим методом (с тем же набором аргументов).

 Сказанное не относится к конструкторам, т.к. они не наследуются и не переопределяются.
 У наследника может быть конструктор, более закрытый, чем у предка.

 Сказанное касается имплементации обычных public abstract методов интерфейсов в классах, которые реализуют данный интерфейс.
 Поэтому, в частности, такие методы могут быть только public.

 Сказанное касается переопределения default методов интерфейсов в классах, которые реализуют данный интерфейс.
 default метод внутри класса, реализующего интерфейс, можно использовать напрямую, можно его переопределить,
 но к нему нельзя обращаться через super. Внутри сторонних классов можно вызвать из объекта класса, реализующего интерфейс,
 дефолтный метод интерфейса (если этот метод не переопределён в классе наследника).

 Сказанное не касается статических методов в интерфейсах. Такие методы можно вызывать только по имени интерфейса,
 но нельзя вызывать из объектов классов или по имени классов, которые имплементируют данный интерфейс. А при перекрытии
 таких методов в классе можно не выполнять объявленные выше правила. Классы, которые имплементируют интерфейс,
 не получают его статические методы – не могут вызывать их напрямую внутри своих классов, а только по имени интерфейса.

 */

public class _02_Methods2 {

    public static void main(String[] args) {

        Parent2.printMessage();
        Child3.printMessage();
        Parent2 parent2 = new Child3();
        parent2.printMessage();
        Child3 child3 = new Child3();
        child3.printMessage();
        new Child4().printMessage("Hello!");
    }
}

class Parent2 {

    public static void printMessage() {

        System.out.println("This is message from Parent2");
    }
}

class Child3 extends Parent2 {

    public static void printMessage() {

        System.out.println("This is message from Child3");
    }
}

class Child4 extends Parent2 {

    public void printMessage(String message) {

        System.out.println("-----------------------------");
        System.out.println("That is message from Child4: " + message);
        super.printMessage();
    }
}
