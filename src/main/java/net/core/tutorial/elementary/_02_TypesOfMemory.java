package net.core.tutorial.elementary;

/*Stack
Когда вызывается метод, то в стеке под него выделяется область памяти "фрейм метода".
Небольшой фрейм выделяется даже для пустого метода. Также во фрейме хранятся локальные переменные метода.
Инструкции, размещённые в методе, хранятся не в стеке и не влияют на размер фрейма метода в стеке.
Как только мы вышли из метода, выделенный для него фрейм удаляется. Вместе с локальными переменными метода.
Для одного потока выделяется порядка 256кБайт-1МБайт стека. При переполнении стека вылетает исключение StackOverflowError.
В настройках JVM можно увеличить объём стека, выделяемый при запуске JVM.
Аргументы метода также можно считать локальными переменными. И при вызове каждого метода выделяется фрейм для хранения этих переменных.
При этом в этом фрейме переменные примитивных типов хранятся в явном виде (например, при прямой рекурсии в каждом фрейме
создаются копии локальных переменных, которые даже если и хранят одинаковые значения, то всё равно в новой области памяти стека).
Если же переменная ссылочного типа (объект класса, массив ...), то во фрейме метода хранится ссылка на область памяти в Heap,
где хранится сам объект/массив. Ссылка занимает 4 байта памяти. При этом, если при рекурсии вложенный метод получает в качестве
аргумента массив, то в его фрейме сохраняется та же ссылка, что и во внешнем методе. И если вложенный метод изменяет значение
в массиве, то при передаче управления во внешний метод изменённое значение массива в Heap сохранится.*/

/*Permanent Generation (Perm Gen).
Область памяти, куда загружаются байтекоды классов, т.е. скомпилированная версия (объект типа Class).
Здесь хранится объявление класса, всех его полей (но не сами значения полей), инструкции (тела методов).
Также здесь хранятся значения статических полей.
Класс загружается в эту область памяти один раз и при рекурсивном вызове метода нет необходимости в этой области памяти выделять
дополнительное место при каждом вызове.
OutOfMemoryError – исключение – вылетает, когда заканчивается память в Perm Gen.*/

/*Heap.
Область памяти, где хранятся ссылочные объекты. Область в Heap выделяется после инструкции new (строки, массивы, коллекции,
объекты классов), а также при использовании строкового литерала при создании строки.
Объект удаляется из Heap, только когда исчезают все ссылки на него из стека. Причём ссылки могут храниться как в локальных
переменных в стеке, так и в самом Heap, например в элементах коллекции. Но на конечный объект прямо или опосредовано должна быть
ссылка из локальной переменной метода (из стека). Т.е. если обнулить ссылку в локальной переменной (в стеке) на коллекцию,
то удалится как объект коллекции, так и объект, на который была ссылка в элементе коллекции.
В Java, в отличие от C++, нет никакой возможности в самом объекте узнать, сколько ссылок ведут к нему.
Объекты без ссылок (из стека) удаляются из Heap сборщиком мусора, который запускается время от времени.
Если для объекта переопределён метод finalize(), то перед уничтожением объекта возможно запустится данный метод.
OutOfMemoryError – исключение – вылетает, когда заканчивается память в Heap.
Но если в бесконечном цикле создавать объекты в Heap, на которые в локальных переменных нет ссылок,
то они будут последовательно уничтожаться мусорщиком и исключение не будет вылетать.
Когда в Heap заканчивается память, то запускается мусорщик, который идёт по всем ссылкам из локальных переменных (из стека)
и по всем ссылкам из статический полей (из Perm Gen). Найденные по ссылкам объекты он оставляет, а вся остальная область памяти
считается свободной (все остальные объекты удаляются).
Для чистоты программирования на Java лучше создавать в процессе выполнения программы много объектов через new, но не сохранять ссылки на них,
чем создавать мало объектов и сохранять ссылки на них в локальные переменные.*/

//Также для JVM выделяется ещё некоторая область памяти за пределами Heap, к которой можно получить доступ при помощи класса ByteBuffer. Здесь не лазит мусорщик.

