package net.core.tutorial.elementary._14_AccessModifiers;

/**

 Модификаторы доступа.

 Java предоставляет набор модификаторов доступа для установки уровня доступа к классам, переменным класса,
 методам и конструкторам.
 Существует два варианта доступа к переменной (или методу) - по ссылке и через наследование:

 1. Доступ по ссылке – это доступ из объекта класса к статическим и нестатическим переменным и методам или по
 имени класса к статическим переменным и методам. Доступ по ссылке может быть внутри стороннего класса или внутри
 класса наследника. В том числе, внутри класса наследника можно обратиться к оригинальной переменной/методу предка
 при помощи ключевого слова super. Это может быть полезно, если оригинальные переменная/метод перекрыты – в классе
 наследника переопределён нестатический метод предка, использован закрывающий (hiding) статический метод или
 объявлена одноимённая переменная (статическая или нестатическая). Ключевое слово super, это фактически ссылка
 на объект текущего класса, как и this, но используемая для доступа к элементам класса, которые унаследованы от предка.
 Поскольку this и super это ссылки на объект, то из них можно обращаться в том числе к статическим переменным/методам,
 но this и super нельзя использовать в статическом контексте;

 2. Через механизм наследования – прямой доступ внутри класса наследника таким образом, как будто это переменные и
 методы, объявленные в самом классе наследника.

 Каждой переменной класса или методу можно указывать только один модификатор доступа.

 1.	Модификатор private.
 К переменной или методу, помеченному модификатором private, можно обращаться только внутри того же класса,
 где он объявлен. Для всех остальных классов такой метод или переменная – недоступны. Это самый закрытый уровень доступа.
 К переменным и методам с модификатором private внутри других классов нет доступа ни по ссылке (в том числе через
 super в классе наследника), ни через механизм наследования. Имеется в виду, что в области памяти объекта наследника
 существует переменная, аналогичная приватной переменной предка, инициализированная тем же значением, какое указано
 в классе предка. Но к этой переменной у наследника нет доступа. И только если у предка есть публичные геттеры для
 этих приватных полей, а наследник эти геттеры унаследовал, не переопределяя, то тогда из объекта наследника можно
 получить при помощи геттеров значения таких приватных полей. Или в самом классе наследника можно вызвать
 унаследованный геттер и получить значение приватного поля предка. Если же наследник переопределил данный геттер,
 то внутри класса наследника можно вызвать геттер предка через super.

 2. Без модификатора.
 Если переменная или метод не помечены никаким модификатором, то считается, что они помечены дефолтным модификатором.
 Переменные или методы без модификатора полноценно доступны по ссылке и через механизм наследования, но только внутри
 классов из того же пакета, что и родной класс. Наследники из другого пакета не наследуют эти поля/методы.
 К таким полям/методам нет доступа из других пакетов ни по ссылке, ни через механизм наследования.
 Нужно помнить, что в интерфейсах методы без модификатора являются неявно public методами, а переменные без
 модификатора являются неявно public final static переменными.

 3. Модификатор protected.

 Можно использовать следующий подход (фича "Павлик Морозов"). Наследник, возможно из другого пакета, получает
 по наследству protected .method() предка и переопределяет его как public. Внутри этого метода вызывается
 super.method(). Теперь данный публичный метод можно вызывать также и из объекта наследника. Если таким образом
 переопределяется метод .clone() из класса Object, то пользовательский класс должен также имплементировать
 интерфейс Cloneable.

 4. Модификатор public.
 Это самый открытый уровень доступа. Полноценный доступ по ссылке и через механизм наследования внутри любых классов.

 Модификаторы private и protected не применимы к классам и интерфейсам.

 */

public class _01_AccessModifiers1 {

    public static void main(String[] args) throws CloneNotSupportedException {

        Child1 child1 = new Child1();
        System.out.println("This is number from private field of Parent: " + child1.getNum());
        System.out.println("This is String from overrided getValue: " + child1.getValue());

        System.out.println("------------------------------");

        SomeClass someClass1 = new SomeClass();
        SomeClass someClass2 = someClass1.clone();
        System.out.println("Исходный объект: " + someClass1.toString() + ", клон объекта: " + someClass2.toString());
    }
}

class Parent1 {

    private String value = "Field of Parent1";
    private int num = 33;

    public String getValue() {
        return value;
    }

    public int getNum() {
        return num;
    }
}

class Child1 extends Parent1 {

    private String value = "Field of Child1";

    public String getValue() {
        return value + ", " + super.getValue();
    }
}

class SomeClass implements Cloneable {

    @Override
    public SomeClass clone() throws CloneNotSupportedException {
        return (SomeClass)super.clone();
    }
}