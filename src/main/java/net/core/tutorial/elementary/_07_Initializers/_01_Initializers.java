package net.core.tutorial.elementary._07_Initializers;

/**
 Инициализатор.

 Динамическое создание объекта – наследника класса ArrayList. Тот же подход, который используется при создании
 анонимного класса. То, что ссылка на созданный объект присваивается переменной list, ничего не значит.
 Анонимный класс – это понятие только для программистов. JVM в любом случае создаёт некую переменную, в которую
 сохраняет ссылку на объект.

 {
 ArrayList list = new ArrayList() {{ add("A"); add("B"); }};
 }

 Если в классе встречается блок кода {}, то это non-static инициализатор. Он вызывается при создании объекта класса,
 перед вызовом конструктора. В данном случае внутри анонимного класса используется ещё один non-static инициализатор,
 в котором вызывается метод .add(), унаследованный от предка.

 Если в классе несколько конструкторов, то общую их часть можно вынести в non-static инициализатор.
 В данном случае мы получаем не просто создание объекта и сохранение ссылки на него в переменную list.
 Прежде создаётся анонимный класс, наследник класса ArrayList. При компиляции будет создан отдельный файл с байт-кодами
 nested класса MainClass$Nest_name1.class.
 Имя nested класса MainClass$Nest_name1.class создаётся только во время компиляции. При написании программы этого
 имени ещё нет и его нельзя использовать. Оно используется уже на этапе исполнения программы, т.е. в Runtime.
 Но всё же можно обойти данную проблему и обратиться к файлу MainClass$Nest_name1.class из программы, использую рефлексию.

 Секция инициализатора может быть статической

 static {
 }

 В этом случае static инициализатор вызывается при первом упоминании класса в коде, даже неявном.
 Например, это может быть static инициализатор в классе, из которого вызывается метод main.
 Он запустится до метода main.

 Пусть класс B extends A.
 При создании объекта B сначала вызовутся статические инициализаторы, начиная с класса предка. А после вызовется
 инициализатор класса предка A и его конструктор. А затем инициализатор класса B и его конструктор.
 Статические инициализаторы вызываются только один раз при первом упоминании класса. Поэтому при создании объекта B
 статические инициализаторы (или один из них) могут не быть вызваны, если они были вызваны ранее.
 Если в классе несколько static инициализаторов, то они вызываются по порядку, сверху вниз. Если в классе несколько
 non-static инициализаторов, то они вызываются по порядку, сверху вниз. Но последний non-static инициализатор
 вызывается всегда перед конструктором. Если выше non-static инициализатора присваивается значение переменной класса
 путём вызова некоторого метода класса, то сначала вызовется метод, а после выполнится инициализатор.

 static инициализатор используется для того, чтобы инициализировать значение static полей класса.
 Если для этой цели использовать non-static инициализатор, то значения static полей будут перезаписываться
 каждый раз при создании нового объекта, а это зачастую не нужно.

 */

public class _01_Initializers {

    public static void main(String[] args) {

        new Test();
        System.out.print("_|");
        new Test();
    }


}

class _Test {

    {
        System.out.print("_BIN");
    }

    static {
        System.out.print("_START");
    }

    public _Test() {
        System.out.print("_BASE");
    }
}

class Test extends _Test {

    {
        System.out.print("_INIT");
    }

    static {
        System.out.print("_STATIC");
    }

    public Test() {
        System.out.print("_CONST");
    }
}
