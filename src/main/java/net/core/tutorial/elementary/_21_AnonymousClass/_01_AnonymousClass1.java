package net.core.tutorial.elementary._21_AnonymousClass;

/**

 Анонимные классы.

 Имеется возможность создавать объекты класса, не присваивая ссылку на объект конкретной переменной,
 если такой объект используется один раз. Например, в качестве аргумента в конструкторе другого класса.

 Более того, можно создать анонимный объект интерфейса (т.е. вернее объект неопределённого класса,
 реализующего данный интерфейс), если здесь же, налету, реализовать методы интерфейса.

 Более того, из анонимного класса можно в месте его объявления вызвать его метод.

 С точки зрения JVM анонимных классов не бывает. Поэтому во время компиляции в папке проекта
 out/production/name_project/name_package/ создастся файл с именем, производным от  имени класса,
 в котором используется анонимный класс. Например, MainClass$Nest_name1.class.
 Для каждого анонимного класса будет создан свой файл (MainClass$Nest_name2.class, MainClass$Nest_name3.class и т.д.).
 Однако если создавать анонимный класс в цикле, то компилятор поймёт, что это один и тот же класс
 и создаст только один файл.

 Проблема анонимных классов:
 Если анонимный класс находится в нестатическом методе, то он автоматически является inner классом.
 А значит необходимо предварительно создать объект внешнего класса (в котором объявлен нестатический метод).
 А значит объект анонимного класса будет содержать ссылку на объект внешнего класса.
 А если объект анонимного класса это Runnable, то он будет существовать пока существует соответствующий
 поток (объект Thread). И всё время будет существовать объект внешнего
 (по отношению к методу, в котором создаётся поток) класса.

 Решение:
 Сделать анонимный класс в статическом методе, чтобы он автоматически стал static nested классом,
 а статический метод вызывать из нестатического метода. Тогда можно создать анонимный объект внешнего класса,
 из него на лету вызвать нестатический метод. Из нестатического метода вызвать статический метод,
 в котором будет создан static nested класс. А анонимный объект внешнего класса будет
 практически мгновенно уничтожен.

 */
public class _01_AnonymousClass1 {

    public static void main(String[] args) {

        // Создание анонимного объекта внешнего класса и вызов нестатического метода
        new _01_AnonymousClass1().thirdPartyMethod();
    }

    public void thirdPartyMethod() {

        // Вызов статического метода из нестатического
        launchRunnable();
    }

    public static void launchRunnable() {

        // Создаём объект анонимного класса
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("I start to do some work");
                try {
                    Thread.sleep(10_000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("I have finished to do some work");
            }
        }).start();
    }
}
