package net.core.tutorial.elementary._04_ScopeOfVariables;

/**
 Видимость переменных.

 1. Переменная, объявленная в методе, существует/видна с начала объявления до конца метода.

 2. Переменная, объявленная в блоке кода, существует до конца этого блока кода.
 Например, внутри цикла while{} объявлена локальная переменная. Когда начнётся следующая итерация цикла этой переменной
 не будет, пока она снова не будет объявлена.

 3. Переменные – аргументы метода – существуют везде внутри метода. Допускается не использовать в теле метода его
 аргумент – это не будет ошибкой при компиляции.
 Локальные переменные метода не имеют дефолтных значений и должны быть инициализированы в методе (необязательно в месте объявления,
 можно позже, но до первого их использования). В том числе ссылочные переменные.

 4. Переменные класса/объекта существуют все время жизни содержащего их объекта. Их видимость дополнительно регулируется
 специальными модификаторами доступа: public, private, protected, default.
 Переменные класса можно не инициализировать. Тогда им присваиваются значения по умолчанию.
 Если переменная является переменной класса, то она привязана к конкретному объекту и существует все время, пока существует
 в памяти объект данного класса. Если нет ни одного объекта, то нет и ни одной копии переменной. К переменной можно обращаться
 (переменная видна) из всех методов класса, независимо от того, объявлены они до неё или после неё. Для каждого объекта
 создаётся своя, независимая от других объектов, переменная.

 5. Статические переменные классов существуют все время работы программы. Их видимость также определяется модификаторами доступа.
 Статическая переменная существует все время, когда существует её класс. Обычно JVM загружает класс в память при первом его
 использовании, тогда же и инициализируются статические переменные.
 Если создать несколько объектов класса, то каждый из них будет содержать свою собственную копию обычных переменных класса.
 Статическая же переменная – общая для всех объектов данного класса и его наследников. Она находится не внутри этих объектов в Heap,
 а в PermGen, и существует даже тогда, когда ни одного объекта класса создано не было.
 Нестатическую переменную a класса A (если она public) можно вызвать из класса B, если создать в нём объект класса A и вызвать
 переменную данного объекта:
 int b = new ClassA().a;
 Статическую переменную a класса A (если она public) можно вызвать из класса B, если вызвать переменную по имени класса A:
 int b = ClassA.a;
 или от имени любого из его объектов:
 int b = new ClassA().a;

 Все переменные, объявленные внутри метода, должны иметь уникальные имена. Аргументы метода также считаются его переменными.
 Переменные класса должны быть уникальными в рамках каждого конкретного класса. Но имена переменных метода и переменных класса
 могут совпадать. В этом случае переменная метода закрывает собой переменную класса. Но к переменной класса тоже можно обратиться,
 только более сложным способом:
 1. Статическая переменная класса.
 ClassName.variableName.
 2. Обычная переменная класса.
 this.variableName.

 Статические методы и переменные привязаны не к объектам класса, а непосредственно к самому классу.
 При вызове нестатического метода в виде объект.имя_метода, на самом деле неявно вызывается метод класса,
 в который первым аргументом передаётся ссылка на тот самый объект. Внутри метода он получает имя this.
 Именно с ним и его данными происходят все действия.

 Зачем нужны статические методы:
 1. Для того, чтобы обратиться к статическим методам и переменным не надо передавать никакую ссылку на объект;
 2. Иногда бывает нужно, чтобы переменная была в единственном экземпляре;
 3. Иногда нужно вызвать метод еще до того, как будет возможность создавать какие-то объекты
 (например, static void main(). Его можно вызвать сразу после загрузки класса в память.
 Еще до того, когда можно будет создавать какие-то объекты).

 final переменные класса можно инициализировать при объявлении, в инициализаторе или в конструкторе.
 static final переменные можно инициализировать при объявлении и в static инициализаторе.

 */

public class _01_ScopeOfVariables {

    static int number = 20;
    final double floatNumber;
    final static boolean key;
    final int value;

    public _01_ScopeOfVariables(int value) {
        this.value = value;
    }

    {
        floatNumber = 5.34;
    }

    static {
        key = true;
    }

    public static int someMethod() {

        int number = 100;
        System.out.println("Number into someMethod = " + number);
        return number;
    }

    public static void otherMethod() {

        int count = 3;

        while(true) {
            int num = 1;
            System.out.println("Internal num = " + num);
            num++;
            if(--count <= 0) break;
        }
    }

    public static void anotherMethod(int number, String message) {

        System.out.println("External number = " + _01_ScopeOfVariables.number);
        System.out.println("Number into anotherMethod = " + number);
    }

    public static void main(String[] args) {

        System.out.println("Number into class = " + number);
        someMethod();
        System.out.println("Number into class = " + number);

        System.out.println("----------------");

        otherMethod();

        System.out.println("----------------");

        anotherMethod(300, "Hello");
    }
}