package net.core.tutorial.elementary._18_CommandLine;

/**

 Утилита jar

 jar-файл – это Java-архив (Java ARchive). Представляет собой ZIP-архив, в котором содержится программа на языке Java.
 jar-файл может быть просто набором классов, т.е. библиотекой. Такой jar элементарно получить при помощи Maven.
 В файле .jar можно объединить исходные файлы .java, откомпилированные файлы .class, различные ресурсы,
 необходимые программе для работы (изображения, текстовые файлы, звуковые файлы и т.д.), документацию
 по работе с программным продуктом, конфигурационные параметры.
 Для того, чтобы вывести в командную строку подсказку по опциям утилиты архиватора необходимо набрать

 jar

 Из подсказки следует, что формат вызова утилиты следующий:

 jar <ctxui>[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files...

 а основные ключи такие:

 -c  Создание нового архива
 -u  Обновление существующего архива
 -t   Выдать на консоль список содержимого архива
 -x  Извлечь названия файлов из архива
 -v  Сгенерировать множественный выход на стандартный выход (вывести результаты архивации на экран командной строки)
 -f   Определить название файла архива
 -m  Включить конфигурационную информацию из файла MANIFEST.MF
 -e   Определить точку входа в приложение для одиночного приложения, упакованного в исполняемый .jar.
 -0   не использовать сжатие zip.
 -C   Изменить определённую директорию и включить в неё следующий файл

 Простой пример:

 jar cvf classes.jar Foo.class Bar.class

 Создание нового архива с именем classes.jar из откомпилированных файлов Foo.class и Bar.class.

 Продолжение базового примера:
 Перейти в папку out/
 Выполнить команду

 jar cvf hello.jar ../src/com/mycompany/app/* com/mycompany/app/*

 При этом в папке out создаться архив hello.jar. Чтобы просмотреть содержимое hello.jar переименуем его
 расширение в zip. Внутри архива находятся META-INF/MANIFEST.MF, src/com/mycompany/app/App.java,
 com/mycompany/app/App.class.
 Файл MANIFEST.MF – это текстовый документ с информацией для JVM.
 Запустить байт-коды на исполнение можно при помощи команды

 java -cp fileName.jar fileName
 или
 java -classpath fileName.jar fileName

 Здесь fileName – это исполняемый класс, содержащий метод main. Таких исполняемых классов может быть несколько.
 В нашем случае, находясь в папке out выполним

 java -cp hello.jar com.mycompany.app.App

 Можно запускать jar-файл на исполнение без указания исполняемого класса, но для этого необходимо сам jar-файл
 сделать исполняемым.
 Чтобы jar-файл был исполняемым, он должен содержать файл MANIFEST.MF в каталоге META-INF, в котором должен
 быть указан главный класс программы (такой класс должен содержать метод main и задаётся параметром Main-Class).
 Номер версии jar задаётся параметром Manifest-Version и является обязательным. В SDK 1.2 значение этого
 параметра должно быть равно 1.0.
 Пример файла MANIFEST.MF:

 Manifest-Version: 1.0
 Created-By: 1.8.0_162 (Oracle Corporation)

 Допишем в данный файл строку
 Main-Class: com.mycompany.app.App

 Теперь запустить байт-коды на исполнение можно при помощи команды

 java -jar hello.jar

 или, как и раньше, указав имя исполняемого файла

 java -jar hello.jar com/mycompany/app/App

 Если в сборке несколько исполняемых файлов, то можно указывать разные имена исполняемых файлов,
 но запустится всё равно тот, который определён в манифесте.

 Создать исполняемый jar-файл легко при помощи Maven, прописав секцию <packaging>jar</packaging>.

 Перед тем как начать выполнение программы JVM анализирует её код. Она читает секции import,
 сигнатуры методов и т.д. Когда она встречает упоминание какого-нибудь класса (неважно, будет ли создан его
 объект, допустим это просто класс возвращаемой методом переменной), то JVM ищет байт-коды (откомпилированные)
 данного класса в classpath (файл .class в папке проекта или в jar-файле). Если байт-кодов упоминаемого класса нет,
 то кидается ClassNotFoundException. Если байт-коды найдены, то JVM проверяет не битые ли они, а затем загружает
 в PermGen. jar-файл может содержать множество откомпилированных классов, библиотек классов, но в PermGen
 загрузятся лишь байт-коды тех классов, которые упоминаются в программе.
 В PermGen создаётся для каждого класса объект типа Class. В этом объекте сохраняются байт-коды методов
 (неважно, статических или нестатических) и полей (у всех объектов программ Java значения полей разные
 (хранятся отдельно в Heap), но байт-коды полей и методов одинаковые). А также в PermGen записываются значения
 всех статических полей. Момент создания статических полей точно не определён. Приближённо можно считать,
 что статические поля (включая значения полей) создаются в PermGen после запуска метода main, когда в коде
 встречается соответствующая инструкция.

 */
public class _03_CommandLine3 {
}
