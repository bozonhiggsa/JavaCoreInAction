package net.core.tutorial.elementary._06_Constructors;

/**

 Если у предка есть явный конструктор, то нет конструктора по умолчанию.
 И если в классе предка не объявить явно так же и конструктор без аргументов, то тогда явный конструктор должен быть
 и у класса наследника. И в конструкторе наследника должен вызываться конструктор предка с аргументами.
 Иначе бы конструктор по умолчанию наследника вызывал конструктор без аргументов предка, которого у предка нет.
 В случае, когда у наследника есть явный конструктор, то в него неявно в первую строку вставляется вызов конструктора
 предка без аргументов, если не вставить самостоятельно в это место вызов конструктора предка с аргументами.

 Поля классов не виртуальны. Поэтому если у предка и наследника есть одноимённое поле, то тип переменной, в которую
 сохраняется ссылка на объект класса наследника, определит то, какое значение для переменной будет использовано - из
 класса предка или из класса наследника.

 Приватные поля не наследуются. Но если у предка есть приватное поле и публичный геттер к нему, то наследник получает
 этот геттер по наследству (как обычный метод). И если наследник не переопределил этот геттер, то из объекта наследника,
 вызвав геттер, можно получить значение приватного поля предка. А значит в объекте наследника хранится
 и это приватное поле от предка.
 Если в классе предка и в классе наследника имеется одноимённое поле, к которому в классе предка имеется публичный геттер,
 а наследник этот геттер наследует не переопределяя, то при вызове из объекта наследника данного геттера будет
 возвращаться значение поля из класса предка. Если же наследник переопределяет данный геттер,
 то при вызове из объекта наследника этого геттера будет возвращаться значение поля из класса наследника.

 В конструкторе можно инициализировать в том числе статическую переменную класса. Но при этом надо помнить,
 что статическая переменная является общей для всех объектов данного класса. Поэтому при создании каждого нового объекта
 значение статической переменной будет перезаписываться (в PermGen).

 */

public class _02_Constructors2 {

    public static void main(String[] args) {

        Child3 child3 = new Child3(100);
        System.out.println("number from Child3 = " + child3.number);

        System.out.println("--------------------");

        Child4 child4 = new Child4(900);
        System.out.println("number from Child4 = " + child4.number);

        Parent3 child4m = new Child4(900);
        System.out.println("number from Child4 = " + child4m.number);

        System.out.println("--------------------");

        Child5 child5 = new Child5();
        System.out.println("value from Child5 = " + child5.value + ", value from Parent4 = " + child5.getValue());

        Child6 child6 = new Child6();
        System.out.println("value from Child6 = " + child6.value + ", value from Parent4 = " + child6.getValue());
    }
}

class Parent2 {

}

class Child3 extends Parent2{

    int number;

    public Child3(int number) {
        //super();
        this.number = number;
    }
}

class Parent3 {

    int number = 20;

}

class Child4 extends Parent3{

    int number;

    public Child4(int number) {
        this.number = number;
    }
}

class Parent4 {

    private int value = 222;

    public int getValue() {
        return value;
    }
}

class Child5 extends Parent4 {

    int value = 333;

}

class Child6 extends Parent4 {

    int value = 555;

    @Override
    public int getValue() {
        return value;
    }
}