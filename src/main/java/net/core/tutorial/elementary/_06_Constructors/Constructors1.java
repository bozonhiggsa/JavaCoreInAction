package net.core.tutorial.elementary._06_Constructors;

/**
 Конструкторы.

 Конструкторы – это специальные методы, назначением которых является создание объектов класса.
 В отличие от обычных методов конструкторы ничего не возвращают (даже void) и
 не могут быть final, static, abstract, synchronized, native.
 Конструкторы классов не наследуются. Поэтому их нельзя переопределять.
 Но можно перегружать (overload) (использовать конструкторы с разным количеством/типом аргументов).
 Уровень доступа конструктора совпадает с уровнем доступа (модификатором) его класса,
 т.е. может быть public или default (package).

 В Java у каждого класса есть хотя бы один конструктор. Если конструктор не сделать явно, то JVM во время
 компиляции сама добавит конструктор по умолчанию (без аргументов), из которого будет вызываться конструктор
 без аргументов предка (через super()).
 Конструктор без аргументов выделяет для полей объекта класса область памяти в Heap и инициализирует их значениями
 по умолчанию. Когда создаётся объект класса через new – выделяется область памяти для хранения всех полей, которые есть
 у данного класса, а также всех полей, которые есть у его предков. Затем обязательно вызываются конструкторы всех предков,
 начиная с самого старшего предка. Последовательно вызываемые конструкторы инициализируют значения полей своих классов.
 В конце вызывается конструктор данного класса, который инициализирует значения своих собственных переменных.

 В результате в объекте наследника имеются инициализированные поля его самого, а также всех его предков. И эти поля могут
 иметь одинаковые имена, но содержать разные значения.

 Если у предка есть явный конструктор, то нет конструктора по умолчанию.
 И если в классе предка не объявить явно так же и конструктор без аргументов, то тогда явный конструктор должен быть
 и у класса наследника. И в конструкторе наследника должен вызываться конструктор предка с аргументами.
 Иначе бы конструктор по умолчанию наследника вызывал конструктор без аргументов предка, которого у предка нет.
 В случае, когда у наследника есть явный конструктор, то в него неявно в первую строку вставляется вызов конструктора
 предка без аргументов, если не вставить самостоятельно в это место вызов конструктора предка с аргументами.

 Если у класса наследника есть явный конструктор, а у предка нет, то при создании объекта наследника в первой строке
 конструктора будет вызван конструктор по умолчанию предка.
 В конструкторе в первой строке всегда стоит или super() (явно или неявно) или this(). this() можно использовать
 для вызова из одного конструктора другого конструктора этого же класса (с другим набором аргументов). Но это не могут
 быть циклические вызовы. Какой-то из конструкторов должен в конце концов всё равно вызвать в первой строке super().

 Приватные поля не наследуются. Но если у предка есть приватное поле и публичный геттер к нему, то наследник получает
 этот геттер по наследству (как обычный метод). И если наследник не переопределил этот геттер, то из объекта наследника,
 вызвав геттер, можно получить значение приватного поля предка. А значит в объекте наследника хранится
 и это приватное поле от предка.
 Если в классе предка и в классе наследника имеется одноимённое поле, к которому в классе предка имеется публичный геттер,
 а наследник этот геттер наследует не переопределяя, то при вызове из объекта наследника данного геттера будет
 возвращаться значение поля из класса предка. Так как поля не виртуальны. Если же наследник переопределяет данный геттер,
 то при вызове из объекта наследника этого геттера будет возвращаться значение поля из класса наследника.

 В конструкторе можно инициализировать в том числе статическую переменную класса. Но при этом надо помнить,
 что статическая переменная является общей для всех объектов данного класса. Поэтому при создании каждого нового объекта
 значение статической переменной будет перезаписываться (в PermGen).

 */
public class Constructors1 {

    public static void main(String[] args) {

        Parent parent = new Parent(100);
        System.out.println("value from Parent = " + parent.value);
        Child1 child1 = new Child1(3, 30);
        System.out.println("value from Child1 = " + child1.value + ", " + "number from Child1 = " + child1.number);
        Child2 child2 = new Child2(70);
        System.out.println("value from Child2 = " + child2.value);
    }
}

class Parent {

    int value;

    Parent(int value) {
        this.value = value;
        System.out.println("-----------------");
        System.out.println("Constructor of Parent is invoked");
        System.out.println("-----------------");
    }
}

class Child1 extends Parent {

    int number;

    Child1(int value, int number) {
        super(value);
        this.number = number;
        System.out.println("Constructor of Child1 is invoked");
        System.out.println("-----------------");
    }
}

class Child2 extends Parent {

    int value;

    Child2(int value) {
        super(value);
        System.out.println("Constructor of Child2 is invoked");
        System.out.println("-----------------");
    }
}